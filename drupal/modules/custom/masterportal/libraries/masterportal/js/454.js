(window.webpackJsonp=window.webpackJsonp||[]).push([[454],{3476:function(d,j,b){var l=Object.create,u=Object.defineProperty,w=Object.getOwnPropertyDescriptor,y=Object.getOwnPropertyNames,O=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty,h=(e,o)=>{for(var r in o)u(e,r,{get:o[r],enumerable:!0})},i=(e,o,r,s)=>{if(o&&typeof o=="object"||typeof o=="function")for(let p of y(o))!g.call(e,p)&&p!==r&&u(e,p,{get:()=>o[p],enumerable:!(s=w(o,p))||s.enumerable});return e},f=(e,o,r)=>(r=e!=null?l(O(e)):{},i(o||!e||!e.__esModule?u(r,"default",{value:e,enumerable:!0}):r,e)),P=e=>i(u({},"__esModule",{value:!0}),e),v={};h(v,{default:()=>t}),d.exports=P(v);var n=f(b(3525));class t extends n.default{decodeBlock(o){const r=new DataView(o),s=[];for(let p=0;p<o.byteLength;++p){let a=r.getInt8(p);if(a<0){const c=r.getUint8(p+1);a=-a;for(let _=0;_<=a;++_)s.push(c);p+=1}else{for(let c=0;c<=a;++c)s.push(r.getUint8(p+c+1));p+=a+1}}return new Uint8Array(s).buffer}}},3525:function(d,j,b){var l=Object.defineProperty,u=Object.getOwnPropertyDescriptor,w=Object.getOwnPropertyNames,y=Object.prototype.hasOwnProperty,O=(n,t)=>{for(var e in t)l(n,e,{get:t[e],enumerable:!0})},g=(n,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of w(t))!y.call(n,r)&&r!==e&&l(n,r,{get:()=>t[r],enumerable:!(o=u(t,r))||o.enumerable});return n},h=n=>g(l({},"__esModule",{value:!0}),n),i=(n,t,e)=>new Promise((o,r)=>{var s=c=>{try{a(e.next(c))}catch(_){r(_)}},p=c=>{try{a(e.throw(c))}catch(_){r(_)}},a=c=>c.done?o(c.value):Promise.resolve(c.value).then(s,p);a((e=e.apply(n,t)).next())}),f={};O(f,{default:()=>v}),d.exports=h(f);var P=b(3526);class v{decode(t,e){return i(this,null,function*(){const o=yield this.decodeBlock(e),r=t.Predictor||1;if(r!==1){const s=!t.StripOffsets,p=s?t.TileWidth:t.ImageWidth,a=s?t.TileLength:t.RowsPerStrip||t.ImageLength;return(0,P.applyPredictor)(o,r,p,a,t.BitsPerSample,t.PlanarConfiguration)}return o})}}},3526:function(d,j,b){var l=Object.defineProperty,u=Object.getOwnPropertyDescriptor,w=Object.getOwnPropertyNames,y=Object.prototype.hasOwnProperty,O=(n,t)=>{for(var e in t)l(n,e,{get:t[e],enumerable:!0})},g=(n,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of w(t))!y.call(n,r)&&r!==e&&l(n,r,{get:()=>t[r],enumerable:!(o=u(t,r))||o.enumerable});return n},h=n=>g(l({},"__esModule",{value:!0}),n),i={};O(i,{applyPredictor:()=>v}),d.exports=h(i);function f(n,t){let e=n.length-t,o=0;do{for(let r=t;r>0;r--)n[o+t]+=n[o],o++;e-=t}while(e>0)}function P(n,t,e){let o=0,r=n.length;const s=r/e;for(;r>t;){for(let a=t;a>0;--a)n[o+t]+=n[o],++o;r-=t}const p=n.slice();for(let a=0;a<s;++a)for(let c=0;c<e;++c)n[e*a+c]=p[(e-c-1)*s+a]}function v(n,t,e,o,r,s){if(!t||t===1)return n;for(let c=0;c<r.length;++c){if(r[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(r[c]!==r[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const p=r[0]/8,a=s===2?1:r.length;for(let c=0;c<o&&!(c*a*e*p>=n.byteLength);++c){let _;if(t===2){switch(r[0]){case 8:_=new Uint8Array(n,c*a*e*p,a*e*p);break;case 16:_=new Uint16Array(n,c*a*e*p,a*e*p/2);break;case 32:_=new Uint32Array(n,c*a*e*p,a*e*p/4);break;default:throw new Error(`Predictor 2 not allowed with ${r[0]} bits per sample.`)}f(_,a,p)}else t===3&&(_=new Uint8Array(n,c*a*e*p,a*e*p),P(_,a,p))}return n}}}]);
